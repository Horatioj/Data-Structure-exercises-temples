1.使用prim或kruskal算法求出最小生成树。



N个点M条边的无向连通图，每条边有一个权值，求该图的最小生成树。



Input
第1行：2个数N,M中间用空格分隔，N为点的数量，M为边的数量。（2 <  N ="1000,"   M ="50000)
第2 - M + 1行：每行3个数S E W，分别表示M条边的2个顶点及权值。(1 <  S E ="N，1"  W ="10000)

Output
输出最小生成树的所有边的权值之和。



样例输入：
9 14
1 2 4
2 3 8
3 4 7
4 5 9
5 6 10
6 7 2
7 8 1
8 9 7
2 8 11
3 9 2
7 9 6
3 6 4
4 6 14
1 8 8
样例输出：
37

/*********************/
提交附件题
1.问题描述

     一个农夫带着一只狼、一只羊和一棵白菜，身处河的南岸。他要把这些东西

 全部运到北岸。他面前只有一条小船，船只能容下他和一件物品，另外只有农夫

 才能撑船。如果农夫在场，则狼不能吃羊，羊不能吃白菜，否则狼会吃羊，羊会

 吃白菜，所以农夫不能留下羊和白菜自己离开，也不能留下狼和羊自己离开，而

 狼不吃白菜。请求出农夫将所有的东西运过河的方案。

2.实现提示

     求解这个问题的简单方法是一步一步进行试探，每一步搜索所有可能的选择

 ，对前一步合适的选择后再考虑下一步的各种方案。要模拟农夫过河问题，首先

 需要对问题中的每个角色的位置进行描述。可用4位二进制数顺序分别表示农夫、

 狼、白菜和羊的位置。用0表在南岸，1表示在北岸。例如，整数5 (0101)表示农

 夫和白菜在南岸，而狼和羊在北岸。

     现在问题变成：从初始的状态二进制0000(全部在河的南岸)出发，寻找一种

 全部由安全状态构成的状态序列，它以二进制1111(全部到达河的北岸)为最终目

 标。总状态共16种(0000到1111)，(或者看成16个顶点的有向图)可采用广度优先

 或深度优先的搜索策略---得到从0000到1111的安全路径。

     以广度优先为例：整数队列---逐层存放下一步可能的安全状态；

     Visited[16]数组标记该状态是否已访问过，若访问过，则记录前驱状态值---安全路径。

     最终的过河方案应用汉字显示出每一步的两岸状态。


自己编写，不要从网上找源代码一改充数，诚信最重要。

要求功能完整。不必拘泥于题目要求，可以有所创新和修改(比如输出形式）。

要求提交文件：

1. 源代码

2. 实验报告（模板见QQ群里）

3. 其他你觉得有必要提交的文件。

以上文件压缩成一个压缩包后上传。



/*********************/
2.编写冒泡排序函数，函数原型：void BubbleSort(int a[],int n);对n个整数升序排序。

编写选择排序函数，函数原型：void SelectionSort(int a[],int n);对n个整数降序排序。

编写main函数，输入10个整数，利用函数将其按升序和降序分别输出排序结果。（输入输出数据间用一个空格分隔）



输入样例：

5 2 8 9 10 1 3 4 7 6



输出样例：

1 2 3 4 5 6 7 8 9 10

10 9 8 7 6 5 4 3 2 1



样例输入：
5 2 8 9 10 1 3 4 7 6
样例输出：
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1


/*********************/
3.定义包含学号、姓名和成绩的学生信息结构类型，完成以下功能： 

（1）键盘输入n个学生信息数据（n从键盘输入）；

（2）使用任一稳定排序算法对学生成绩由高到低排序；

（3）输出排序后学生信息。



输入输出样例如下,数据间以空格分隔。



输入样例：

3

100001 wang-li 91

100002 chen-da-wei 93

100003 guo-tao 93



输出样例：

100002 chen-da-wei 93

100003 guo-tao 93 

100001 wang-li 91



样例输入：
2
111111 wang 78
222222 liu 100 
样例输出：
222222 liu 100
111111 wang 78


/*********************/
3.编写归并排序算法，对n个整数升序排序。归并排序代码结构如下：



void recordList::MergeSort(recordList &L){
    MSort(L, L, 0, L.currentSize-1);
}


编写堆排序函数，对n个整数降序排序。堆排序参考代码如下：



void MaxHeap::HeapSort(){
   //对表heap[0]到heap[n-1]进行排序，使得表中各个待排序记录按其关键字，非递减排序
       for(int i=(CurrentSize-2)/2;i>=0;i--)          
                 FilterDown(i,CurrentSize-1);  //建立初始大顶堆
    for(int i=CurrentSize-1;i>=1;i--){
            swap(heap[0],heap[i]);     //交换元素
            FilterDown(0,i-1);        //重新构建最大堆
      }
 }



编写main函数，输入n个整数，利用写好的归并排序算法和堆排序算法将其按升序和降序分别输出排序结果。（输入输出数据间用一个空格分隔）


输入样例格式为2行：
整数个数n
n个整数


输出样例格式为2行：
排好序的升序序列
排好序的降序序列

样例输入：
10
5 2 8 9 10 1 3 4 7 6
样例输出：
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1


/*********************/
从简单排序和高级排序里分别任选1种排序算法，理解该排序的思想，参考一些排序视频和flash动图做一个相应排序算法的展示，形式不限，可以是录制小视频、制作flash动图、文本文件等。

简单排序：冒泡、简单插入、简单选择

高级排序：希尔、快速、归并、堆、锦标赛、基数排序等


如果是多个文件，可以压缩为一个文件。