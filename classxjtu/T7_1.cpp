//通过了第四周第七题
//最大子序列的和
/*
给定一个K整数序列{ N1, N2, ..., NK}。一个连续子序列定义为{{ Ni, Ni+1, ..., Nj }，
其中 1 <= i <= j <= K。k的最大子序列是其元素最大和的连续子序列。
例如，给定序列{ -2, 11, -4, 13, -5, -2 }，其最大子序列为{11, -4, 13 }，最大和为20。

现在找到最大的总和，连同第一个和最后一个最大子序列的数字。

输入格式：

每个样例都有两行。第一行包含正整数K（≤10000）。第二行包含K个数字，用空格隔开。

输出格式：

对于每一个测试用例，在一行中输出最大的总和，连同第一个子序列和最后一个子序列的最大子序列。
数字必须用一个空格隔开，但行尾不能有多余的空格。在最大子序列不是唯一的情况下，
输出具有最小指数i和j（如样本实例所示）的序列。如果所有的K数都是负的，那么它的最大和被定义为0，
并且输出整个序列的第一个和最后一个数字。

输入样例：

10

-10 1 2 3 4 -5 -23 3 7 -21

输出样例：

10 1 4

样例说明：

{1，2，3，4}和{3，7}都是具有最大和的子序列。但是，应该输出前一个。
这里1和4是子序列中1和4的索引。索引从0到K-1。

*/

#include<iostream>
using namespace std;
int main(){
    int k;
    cin >> k;
    if(k <= 0 || k > 10000) return false;
    int *n = new int[k];
    for(int i = 0; i < k; i++)
    {
    	cin >> n[i];
		while(cin.fail()) return false;
	}
    int sum = 0, a = 0, b = 0, max1 = 0;
    int a1 = 0;
    int temp = 0; //定义一个变量 
    for(int i = 0 ; i < k; i++){
        if(n[i] >= 0)//只要有一个大于等于0的num就将temp赋值为1 
        {
        	temp = 1;
		}
        if(sum + n[i] < 0){
        sum = 0;
        a1 = i + 1; 
        }else{
        sum = sum + n[i];
        }
        if(sum > max1){
        max1 = sum;
        b = i;
        a = a1;
        }
    }
    if(temp == 0)//temp为0表示输入全是负数 
    {
    	cout << sum << " " << n[0] << " " << n[k-1] << endl;
	}
	else
	{
    	cout << max1 << " " << a << " " << b << endl;
    }
    delete []n;
    return 0;
}