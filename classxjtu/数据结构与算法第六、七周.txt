1.创建一个字符线性表（顺序表），并实现其基本操作（如插入，查找，删除，输出等）。应用该线性表，将键盘输入的一行字符插入表中，然后输出表中所有字符及表长；再输入一个字符，从表中删除该字符（重复出现应进行多次删除），最后再次输出表中所有字符及表长。
输入样例：
ABCBBDEF 12XYZBA
输出样例：
ABCBBDEF 12XYZBA
16
再输入：
B
则输出为：
ACDEF 12XYZA
12

2.题目描述：
利用字符栈检查表达式的括号是否匹配。
提示：
从左向右扫描表达式，遇到“（”进栈，遇到“)”出栈，扫描完表达式后，若栈空，表示括号匹配。否则，
（1）当扫描完表达式后棧不空，可断定括号是不匹配的
（2）表达式未扫描完，需要出棧时棧是空的，此时可断定括号是不匹配的。
 
输入输出格式：
输入：一个表达式
输出：括号匹配！或 括号不匹配！
 
样例：
输入：
(a+b)*(5+c)*((22-c)/23+56)
输出：
括号匹配！
 
输入:
2+(5+8))
输出：
括号不匹配！


3.题目描述：

设计一个队列，将任意n个整数入队（n值从键盘读入，n>2），再将队列的前两个元素输出（即出队），

随后将11和12入队，再次输出队列中的所有元素。



输入输出格式：

输入：n个整数（n>2）

输出：队列中的所有元素

 

样例：

6

1 2 3 4 5 6

3 4 5 6 11 12


4.哈夫曼编码构造算法：

　　【步骤1】由给定的 n 个字母 {C0,C1,C2,…, Cn-1}和权值 {W0,W1,W2,…, Wn-1}，构造具有n棵扩充二叉树的森林F = { T0,T1,T2,…, Tn-1 }，其中每棵扩充二叉树Ti只有一个带权值Wi的根结点，其左、右子树均为空；

　　【步骤2】在F中选取两棵根结点权值最小的扩充二叉树，作为左、右子树构造一棵新的二叉树，并置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和；

　　【步骤3】在F中删去这两棵二叉树；

　　【步骤4】把新的二叉树加入F中；

　　【步骤5】重复步骤2～步骤4， 直到F中仅剩下一棵二叉树为止，即为所求哈夫曼树。


输入格式

第一行：结点的数量

第二行：各个结点的权值

输出格式

第一行：计算该哈夫曼树的WPL

第二行：按照括号的形式输出其哈弗曼树（参考样例输出格式）

第三行：按照哈夫曼编码的由左子树到右子树输出对应权重的编码，不同编码中间用空格隔开(为了减轻难度，最后一个编码后面需加上空格)（如果编码长度相等，从左到右按照0到1的格式输出，参考样例输出格式）

样例输入：
5
7 5 3 1 8
样例输出：
52
24(9(4(1,3),5),15(7,8))
000 001 01 10 11 



5.提交附件，中作业
	1）问题描述

     设计一个一元稀疏多项式简单计算器。

	2）基本要求

     一元稀疏多项式简单计算器的基本功能是：

     (1)输入并建立多项式；

     (2)输出多项式，输出形式为整数序列： n,c1,e1,c2,e2,…,cn,en,

        其中n是多项式的项数，ci,ei分别是第i项的系数和指数，序列按指数降序排列；

     (3)多项式a和b相加，建立多项式a+b；

     (4)多项式a和b相减，建立多项式a-b；

     (5)计算多项式在x处的值；即给定x值，计算多项式值。

	3）实现提示

     用带表头结点的单链表存储多项式，多项式的项数存放在头结点中。
